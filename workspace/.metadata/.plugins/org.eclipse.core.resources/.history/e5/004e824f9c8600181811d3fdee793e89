

#include <xlnx_zynq7k.h>



#include <sys/mman.h>
#include <stdlib.h>
#include <stdint.h>

#include <unistd.h>
#include <time.h>
#include <taskLib.h>
#include <stdio.h>
#include <kernelLib.h>
#include <semLib.h>
#include <intLib.h>
#include <iv.h>

#include <xlnx_zynq7k.h>

/*
 * Next macros provides location of knobs and LEDs peripherals
 * implemented in MZ_APO FPGA design.
 *
 * The complete list of peripheral implemented in the design
 * can be found on the page
 *   https://cw.fel.cvut.cz/wiki/courses/b35apo/documentation/mz_apo/start
 */

/*
 * Base address of the region used for mapping of the knobs and LEDs
 * peripherals in the ARM Cortex-A9 physical memory address space.
 */
#define BASE_PHYS 0x43c20000

/* Valid address range for the region */
#define SPILED_REG_SIZE      0x00004000

/*
 * Byte offset of the register which controls individual LEDs
 * in the row of 32 yellow LEDs. When the corresponding bit
 * is set (value 1) then the LED is lit.
 */
#define SPILED_REG_LED_LINE_o           0x004

/*
 * The register to control 8 bit RGB components of brightness
 * of the first RGB LED
 */
#define SPILED_REG_LED_RGB1_o           0x010

/*
 * The register to control 8 bit RGB components of brightness
 * of the second RGB LED
 */
#define SPILED_REG_LED_RGB2_o           0x014

/*
 * The register which combines direct write to RGB signals
 * of the RGB LEDs, write to the keyboard scan register
 * and control of the two additional individual LEDs.
 * The direct write to RGB signals is orred with PWM
 * signal generated according to the values in previous
 * registers.
 */
#define SPILED_REG_LED_KBDWR_DIRECT_o   0x018

/*
 * Register providing access to unfiltered encoder channels
 * and keyboard return signals.
 */
#define SPILED_REG_KBDRD_KNOBS_DIRECT_o 0x020

/*
 * The register representing knobs positions as three
 * 8-bit values where each value is incremented
 * and decremented by the knob relative turning.
 */
#define SPILED_REG_KNOBS_8BIT_o         0x024


char c = '\0';
SEM_ID irc_sem;
volatile int irc_a, irc_b;
volatile int cnt = 0;


void irc_print_status(void)
{
        while (1) {
                semTake(irc_sem, WAIT_FOREVER);
                printf("b: %d, a: %d\n", irc_b, irc_a);
                printf("cnt: %d\n",cnt);
        }
}

void irc_isr(void)
{
        int sr; /* status register */
        sr = *(volatile uint32_t *) (0x43c20000 + 0x0004);
        irc_a = (sr & 0x100) >> 8;
        irc_b = (sr & 0x200) >> 9;
        cnt += 1; 
        
        semGive(irc_sem);
        *(volatile uint32_t *) (ZYNQ7K_GPIO_BASE + 0x00000298) = 0x4; /* reset (stat) */
}

/*
 *  Enable IRQ
 *
 *  See TRM, 14.2.4 Interrupt Function (pg. 391, pg. 1348). Technical reference
 *  manual link is on rtime HW wiki: https://rtime.felk.cvut.cz/hw/index.php/Zynq
 */
void irc_init(void)
{
        *(volatile uint32_t *) (ZYNQ7K_GPIO_BASE + 0x00000298) = 0x4; /* reset (stat) */
        *(volatile uint32_t *) (ZYNQ7K_GPIO_BASE + 0x00000284) = 0x0; /* set as input (dirm) */
        *(volatile uint32_t *) (ZYNQ7K_GPIO_BASE + 0x0000029c) = 0x4; /* rising edge (type) */
        *(volatile uint32_t *) (ZYNQ7K_GPIO_BASE + 0x000002a0) = 0x0; /* rising edge (polarity) */
        *(volatile uint32_t *) (ZYNQ7K_GPIO_BASE + 0x000002a4) = 0x0; /* rising edge (any) */
        *(volatile uint32_t *) (ZYNQ7K_GPIO_BASE + 0x00000290) = 0x4; /* enable interrupt (en) GPIO2 */

        intConnect(INUM_TO_IVEC(INT_LVL_GPIO), irc_isr, 0);
        intEnable(INT_LVL_GPIO);
}

void irc_disable(void)
{
        *(volatile uint32_t *) (ZYNQ7K_GPIO_BASE + 0x00000294) = 0x4; /* disable interrupt (dis) */
        intDisable(INT_LVL_GPIO);
        intDisconnect(INUM_TO_IVEC(INT_LVL_GPIO), irc_isr, 0);
}

/*
void counter_function(void)
{
	
}

*/

void motor(void)
{
        TASK_ID st;

        irc_init();
        irc_sem = semCCreate(SEM_Q_FIFO, 0);
        st = taskSpawn("irc_st", 100, 0, 4096, (FUNCPTR) irc_print_status, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        printf("All is ready.\n");

        taskDelay(1000);
        printf("Out of play time.\n");

        irc_disable();
        taskDelete(st);
}




void rot_mot(int desired)
{
	while(1){
		if (cnt < desired)
		{
			*(volatile uint32_t*)(BASE_PHYS + 0x000C) = 0x80000001;
		}
		else
		{
			sleep(10);
			*(volatile uint32_t*)(BASE_PHYS + 0x000C) = 0x80000000;
			
		}
		motor();
	}
}	
	
	
	
	
/*
 * Entry point for DKM.
 */




/*
 * The main entry into example program
 */
int main(int argc, char *argv[])
{
	
	
	
	volatile int cnt = 0;

    *(volatile uint32_t*)(BASE_PHYS + 0x0000) = 0x40;
    *(volatile uint32_t*)(BASE_PHYS + 0x0008) = 0x2;
    

	   
	   
	   //motor();
	   rot_mot(1000);
    
    
/*
    counter = taskSpawn("counter1", 210, 0, 4096, (FUNCPTR) counter_function, cnt, 0, 0, 0, 0, 0, 0, 0, 0, 0); 
    
    
    
    
     while (1) {
             c = getchar();
             switch (c) {
             	 case('R'):
                 {
                     printf("turning right\n");
                     *(volatile uint32_t*)(BASE_PHYS + 0x000C) = 0x80000001;
                     motor();
                     break;
                 }
                 
                     case('L'):
                     {
                         printf("turning left\n");
                         *(volatile uint32_t*)(BASE_PHYS + 0x000C) = 0x40000001;
                         break;
                     }
                    
                     case('S'):
                     {
                         printf("Stop from working\n");
                         *(volatile uint32_t*)(BASE_PHYS + 0x000C) = 0x40000000;
                         motor();
                         break;
                     }
                     default:
                          {
                              printf("Wrong input!\n");
                              break;
                          }
                          
           }
       }

 */   
    /* *(volatile uint32_t*)(BASE_PHYS + 0x0000) = 0x40;
     *(volatile uint32_t*)(BASE_PHYS + 0x0008) = 0x2;
     *(volatile uint32_t*)(BASE_PHYS + 0x000C) = 0x80000001;*/
     
    // *(volatile uint32_t*)(BASE_PHYS + 0x000C) = 0x40000001;
     
   //motor();
     
     


  return 0;
}
